# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _mc
else:
    import _mc

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


PRIuPTR = _mc.PRIuPTR

PRIdPTR = _mc.PRIdPTR

LLU = _mc.LLU

LLO = _mc.LLO

LLX = _mc.LLX

false = _mc.false

true = _mc.true

OUTCOME_GENERIC_ERROR = _mc.OUTCOME_GENERIC_ERROR

OUTCOME_PARSER_ERROR = _mc.OUTCOME_PARSER_ERROR

OUTCOME_SYNTAX_ERROR = _mc.OUTCOME_SYNTAX_ERROR

OUTCOME_FILE_ERROR = _mc.OUTCOME_FILE_ERROR

OUTCOME_SUCCESS_REQUIRED_HELP = _mc.OUTCOME_SUCCESS_REQUIRED_HELP

OUTCOME_SUCCESS = _mc.OUTCOME_SUCCESS


def Mc_Init():
    r"""Mc_Init()"""
    return _mc.Mc_Init()

def Mc_End():
    r"""Mc_End()"""
    return _mc.Mc_End()

def Mc_CheckCTLSpec(prop):
    r"""Mc_CheckCTLSpec(Prop_ptr prop)"""
    return _mc.Mc_CheckCTLSpec(prop)

def Mc_CheckAGOnlySpec(prop):
    r"""Mc_CheckAGOnlySpec(Prop_ptr prop)"""
    return _mc.Mc_CheckAGOnlySpec(prop)

def Mc_CheckInvar(prop):
    r"""Mc_CheckInvar(Prop_ptr prop)"""
    return _mc.Mc_CheckInvar(prop)

def Mc_CheckInvarSilently(prop, trace):
    r"""Mc_CheckInvarSilently(Prop_ptr prop, Trace_ptr * trace)"""
    return _mc.Mc_CheckInvarSilently(prop, trace)

def Mc_CheckInvar_With_Strategy(prop, strategy, trace, silent):
    r"""Mc_CheckInvar_With_Strategy(Prop_ptr prop, Check_Strategy strategy, Trace_ptr * trace, boolean silent)"""
    return _mc.Mc_CheckInvar_With_Strategy(prop, strategy, trace, silent)

def Mc_CheckInvar_With_Strategy_And_Symbols(prop, strategy, trace, silent, symbols):
    r"""Mc_CheckInvar_With_Strategy_And_Symbols(Prop_ptr prop, Check_Strategy strategy, Trace_ptr * trace, boolean silent, NodeList_ptr symbols)"""
    return _mc.Mc_CheckInvar_With_Strategy_And_Symbols(prop, strategy, trace, silent, symbols)

def Mc_CheckCompute(prop):
    r"""Mc_CheckCompute(Prop_ptr prop)"""
    return _mc.Mc_CheckCompute(prop)

def Mc_check_psl_property(prop):
    r"""Mc_check_psl_property(Prop_ptr prop) -> int"""
    return _mc.Mc_check_psl_property(prop)

def Mc_CheckLanguageEmptiness(fsm, allinit, verbose):
    r"""Mc_CheckLanguageEmptiness(BddFsm_ptr const fsm, boolean allinit, boolean verbose)"""
    return _mc.Mc_CheckLanguageEmptiness(fsm, allinit, verbose)

def Mc_rewrite_invar_get_sexp_fsm(prop, layer, created_var):
    r"""Mc_rewrite_invar_get_sexp_fsm(Prop_ptr const prop, SymbLayer_ptr layer, node_ptr * created_var) -> SexpFsm_ptr"""
    return _mc.Mc_rewrite_invar_get_sexp_fsm(prop, layer, created_var)

def Mc_create_trace_from_bdd_state_input_list(bdd_enc, symbols, desc, type, path):
    r"""Mc_create_trace_from_bdd_state_input_list(BddEnc_ptr const bdd_enc, NodeList_ptr const symbols, char const * desc, TraceType const type, node_ptr path) -> Trace_ptr"""
    return _mc.Mc_create_trace_from_bdd_state_input_list(bdd_enc, symbols, desc, type, path)

def Mc_fill_trace_from_bdd_state_input_list(bdd_enc, trace, path):
    r"""Mc_fill_trace_from_bdd_state_input_list(BddEnc_ptr const bdd_enc, Trace_ptr trace, node_ptr path) -> Trace_ptr"""
    return _mc.Mc_fill_trace_from_bdd_state_input_list(bdd_enc, trace, path)

def Mc_trace_step_put_state_from_bdd(trace, step, bdd_enc, bdd):
    r"""Mc_trace_step_put_state_from_bdd(Trace_ptr trace, TraceIter step, BddEnc_ptr bdd_enc, bdd_ptr bdd)"""
    return _mc.Mc_trace_step_put_state_from_bdd(trace, step, bdd_enc, bdd)

def Mc_trace_step_put_input_from_bdd(trace, step, bdd_enc, bdd):
    r"""Mc_trace_step_put_input_from_bdd(Trace_ptr trace, TraceIter step, BddEnc_ptr bdd_enc, bdd_ptr bdd)"""
    return _mc.Mc_trace_step_put_input_from_bdd(trace, step, bdd_enc, bdd)

def print_spec(file, prop):
    r"""print_spec(FILE * file, Prop_ptr prop)"""
    return _mc.print_spec(file, prop)

def print_invar(file, n):
    r"""print_invar(FILE * file, Prop_ptr n)"""
    return _mc.print_invar(file, n)

def print_compute(arg1, arg2):
    r"""print_compute(FILE * arg1, Prop_ptr arg2)"""
    return _mc.print_compute(arg1, arg2)

def ex(arg1, arg2):
    r"""ex(BddFsm_ptr arg1, BddStates arg2) -> BddStates"""
    return _mc.ex(arg1, arg2)

def ef(arg1, arg2):
    r"""ef(BddFsm_ptr arg1, BddStates arg2) -> BddStates"""
    return _mc.ef(arg1, arg2)

def eg(arg1, arg2):
    r"""eg(BddFsm_ptr arg1, BddStates arg2) -> BddStates"""
    return _mc.eg(arg1, arg2)

def eu(arg1, arg2, arg3):
    r"""eu(BddFsm_ptr arg1, BddStates arg2, BddStates arg3) -> BddStates"""
    return _mc.eu(arg1, arg2, arg3)

def au(arg1, arg2, arg3):
    r"""au(BddFsm_ptr arg1, BddStates arg2, BddStates arg3) -> BddStates"""
    return _mc.au(arg1, arg2, arg3)

def ebu(arg1, arg2, arg3, arg4, arg5):
    r"""ebu(BddFsm_ptr arg1, BddStates arg2, BddStates arg3, int arg4, int arg5) -> BddStates"""
    return _mc.ebu(arg1, arg2, arg3, arg4, arg5)

def ebf(arg1, arg2, arg3, arg4):
    r"""ebf(BddFsm_ptr arg1, BddStates arg2, int arg3, int arg4) -> BddStates"""
    return _mc.ebf(arg1, arg2, arg3, arg4)

def ebg(arg1, arg2, arg3, arg4):
    r"""ebg(BddFsm_ptr arg1, BddStates arg2, int arg3, int arg4) -> BddStates"""
    return _mc.ebg(arg1, arg2, arg3, arg4)

def abu(arg1, arg2, arg3, arg4, arg5):
    r"""abu(BddFsm_ptr arg1, BddStates arg2, BddStates arg3, int arg4, int arg5) -> BddStates"""
    return _mc.abu(arg1, arg2, arg3, arg4, arg5)

def minu(arg1, arg2, arg3):
    r"""minu(BddFsm_ptr arg1, bdd_ptr arg2, bdd_ptr arg3) -> int"""
    return _mc.minu(arg1, arg2, arg3)

def maxu(arg1, arg2, arg3):
    r"""maxu(BddFsm_ptr arg1, bdd_ptr arg2, bdd_ptr arg3) -> int"""
    return _mc.maxu(arg1, arg2, arg3)

def explain(arg1, arg2, arg3, arg4, arg5):
    r"""explain(BddFsm_ptr arg1, BddEnc_ptr arg2, node_ptr arg3, node_ptr arg4, node_ptr arg5) -> node_ptr"""
    return _mc.explain(arg1, arg2, arg3, arg4, arg5)

def eval_ctl_spec(arg1, enc, arg3, arg4):
    r"""eval_ctl_spec(BddFsm_ptr arg1, BddEnc_ptr enc, node_ptr arg3, node_ptr arg4) -> bdd_ptr"""
    return _mc.eval_ctl_spec(arg1, enc, arg3, arg4)

def eval_formula_list(arg1, enc, arg3, arg4):
    r"""eval_formula_list(BddFsm_ptr arg1, BddEnc_ptr enc, node_ptr arg3, node_ptr arg4) -> node_ptr"""
    return _mc.eval_formula_list(arg1, enc, arg3, arg4)

def eval_compute(arg1, enc, arg3, arg4):
    r"""eval_compute(BddFsm_ptr arg1, BddEnc_ptr enc, node_ptr arg3, node_ptr arg4) -> int"""
    return _mc.eval_compute(arg1, enc, arg3, arg4)

def free_formula_list(arg1, arg2):
    r"""free_formula_list(DdManager * arg1, node_ptr arg2)"""
    return _mc.free_formula_list(arg1, arg2)

def ex_explain(arg1, arg2, arg3, arg4):
    r"""ex_explain(BddFsm_ptr arg1, BddEnc_ptr arg2, node_ptr arg3, bdd_ptr arg4) -> node_ptr"""
    return _mc.ex_explain(arg1, arg2, arg3, arg4)

def eu_explain(arg1, arg2, arg3, arg4, arg5):
    r"""eu_explain(BddFsm_ptr arg1, BddEnc_ptr arg2, node_ptr arg3, bdd_ptr arg4, bdd_ptr arg5) -> node_ptr"""
    return _mc.eu_explain(arg1, arg2, arg3, arg4, arg5)

def eu_si_explain(fsm, enc, path, f, g_si, hulk):
    r"""eu_si_explain(BddFsm_ptr fsm, BddEnc_ptr enc, node_ptr path, bdd_ptr f, bdd_ptr g_si, bdd_ptr hulk) -> node_ptr"""
    return _mc.eu_si_explain(fsm, enc, path, f, g_si, hulk)

def ex_si(fsm, si):
    r"""ex_si(BddFsm_ptr fsm, bdd_ptr si) -> BddStatesInputs"""
    return _mc.ex_si(fsm, si)

def eu_si(fsm, f, g):
    r"""eu_si(BddFsm_ptr fsm, bdd_ptr f, bdd_ptr g) -> BddStatesInputs"""
    return _mc.eu_si(fsm, f, g)

def eg_si(fsm, g_si):
    r"""eg_si(BddFsm_ptr fsm, bdd_ptr g_si) -> BddStatesInputs"""
    return _mc.eg_si(fsm, g_si)

def ebu_explain(arg1, arg2, arg3, arg4, arg5, arg6, arg7):
    r"""ebu_explain(BddFsm_ptr arg1, BddEnc_ptr arg2, node_ptr arg3, bdd_ptr arg4, bdd_ptr arg5, int arg6, int arg7) -> node_ptr"""
    return _mc.ebu_explain(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

def eg_explain(arg1, arg2, arg3, arg4):
    r"""eg_explain(BddFsm_ptr arg1, BddEnc_ptr arg2, node_ptr arg3, bdd_ptr arg4) -> node_ptr"""
    return _mc.eg_explain(arg1, arg2, arg3, arg4)

def ebg_explain(arg1, arg2, arg3, arg4, arg5, arg6):
    r"""ebg_explain(BddFsm_ptr arg1, BddEnc_ptr arg2, node_ptr arg3, bdd_ptr arg4, int arg5, int arg6) -> node_ptr"""
    return _mc.ebg_explain(arg1, arg2, arg3, arg4, arg5, arg6)

cvar = _mc.cvar

