# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _node
else:
    import _node

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def node2bdd(ptr):
    r"""node2bdd(node ptr) -> bdd_ptr"""
    return _node.node2bdd(ptr)

def bdd2node(ptr):
    r"""bdd2node(bdd_ptr ptr) -> node"""
    return _node.bdd2node(ptr)

def int2node(val):
    r"""int2node(int val) -> node"""
    return _node.int2node(val)

def node2int(ptr):
    r"""node2int(node ptr) -> int"""
    return _node.node2int(ptr)

def string2node(string):
    r"""string2node(string_ptr string) -> node"""
    return _node.string2node(string)

def node2string(node):
    r"""node2string(node node) -> string_ptr"""
    return _node.node2string(node)

def node2word(node):
    r"""node2word(node node) -> WordNumber_ptr"""
    return _node.node2word(node)

def word2node(word):
    r"""word2node(WordNumber_ptr word) -> node"""
    return _node.word2node(word)

def node_equal(left, right):
    r"""node_equal(node left, node right) -> boolean"""
    return _node.node_equal(left, right)
PRIuPTR = _node.PRIuPTR

PRIdPTR = _node.PRIdPTR

LLU = _node.LLU

LLO = _node.LLO

LLX = _node.LLX

false = _node.false

true = _node.true

OUTCOME_GENERIC_ERROR = _node.OUTCOME_GENERIC_ERROR

OUTCOME_PARSER_ERROR = _node.OUTCOME_PARSER_ERROR

OUTCOME_SYNTAX_ERROR = _node.OUTCOME_SYNTAX_ERROR

OUTCOME_FILE_ERROR = _node.OUTCOME_FILE_ERROR

OUTCOME_SUCCESS_REQUIRED_HELP = _node.OUTCOME_SUCCESS_REQUIRED_HELP

OUTCOME_SUCCESS = _node.OUTCOME_SUCCESS


def MasterNodeWalker_create():
    r"""MasterNodeWalker_create() -> MasterNodeWalker_ptr"""
    return _node.MasterNodeWalker_create()

def MasterNodeWalker_destroy(_self):
    r"""MasterNodeWalker_destroy(MasterNodeWalker_ptr _self)"""
    return _node.MasterNodeWalker_destroy(_self)

def MasterNodeWalker_register_walker(_self, walker):
    r"""MasterNodeWalker_register_walker(MasterNodeWalker_ptr _self, NodeWalker_ptr walker) -> boolean"""
    return _node.MasterNodeWalker_register_walker(_self, walker)

def MasterNodeWalker_unregister_walker(_self, name):
    r"""MasterNodeWalker_unregister_walker(MasterNodeWalker_ptr _self, char const * name) -> NodeWalker_ptr"""
    return _node.MasterNodeWalker_unregister_walker(_self, name)
class value_(object):
    r"""Proxy of C value_ struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    inttype = property(_node.value__inttype_get, _node.value__inttype_set, doc=r"""inttype : int""")
    nodetype = property(_node.value__nodetype_get, _node.value__nodetype_set, doc=r"""nodetype : p.struct node""")
    strtype = property(_node.value__strtype_get, _node.value__strtype_set, doc=r"""strtype : p.struct string_""")
    bddtype = property(_node.value__bddtype_get, _node.value__bddtype_set, doc=r"""bddtype : p.void""")

    def __init__(self):
        r"""__init__(value_ self) -> value_"""
        _node.value__swiginit(self, _node.new_value_())
    __swig_destroy__ = _node.delete_value_

# Register value_ in _node:
_node.value__swigregister(value_)
class node(object):
    r"""Proxy of C node struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    link = property(_node.node_link_get, _node.node_link_set, doc=r"""link : p.struct node""")
    type = property(_node.node_type_get, _node.node_type_set, doc=r"""type : short""")
    lineno = property(_node.node_lineno_get, _node.node_lineno_set, doc=r"""lineno : int""")
    left = property(_node.node_left_get, _node.node_left_set, doc=r"""left : node_val""")
    right = property(_node.node_right_get, _node.node_right_set, doc=r"""right : node_val""")
    extra_data = property(_node.node_extra_data_get, _node.node_extra_data_set, doc=r"""extra_data : p.void""")

    def __init__(self):
        r"""__init__(node self) -> node"""
        _node.node_swiginit(self, _node.new_node())
    __swig_destroy__ = _node.delete_node

# Register node in _node:
_node.node_swigregister(node)

def node_pkg_init():
    r"""node_pkg_init()"""
    return _node.node_pkg_init()

def node_pkg_quit():
    r"""node_pkg_quit()"""
    return _node.node_pkg_quit()

def free_node(arg1):
    r"""free_node(node arg1)"""
    return _node.free_node(arg1)

def swap_nodes(arg1, arg2):
    r"""swap_nodes(node_ptr * arg1, node_ptr * arg2)"""
    return _node.swap_nodes(arg1, arg2)

def node_is_failure(node):
    r"""node_is_failure(node node) -> int"""
    return _node.node_is_failure(node)

def node_is_leaf(node):
    r"""node_is_leaf(node node) -> int"""
    return _node.node_is_leaf(node)

def walk(fun, arg2):
    r"""walk(VPFN fun, node arg2)"""
    return _node.walk(fun, arg2)

def create_node(arg1, arg2, arg3):
    r"""create_node(int arg1, node arg2, node arg3) -> node"""
    return _node.create_node(arg1, arg2, arg3)

def new_lined_node(arg1, arg2, arg3, arg4):
    r"""new_lined_node(int arg1, node arg2, node arg3, int arg4) -> node"""
    return _node.new_lined_node(arg1, arg2, arg3, arg4)

def cons(arg1, arg2):
    r"""cons(node arg1, node arg2) -> node"""
    return _node.cons(arg1, arg2)

def car(arg1):
    r"""car(node arg1) -> node"""
    return _node.car(arg1)

def cdr(arg1):
    r"""cdr(node arg1) -> node"""
    return _node.cdr(arg1)

def new_list():
    r"""new_list() -> node"""
    return _node.new_list()

def copy_list(l):
    r"""copy_list(node l) -> node"""
    return _node.copy_list(l)

def free_list(l):
    r"""free_list(node l)"""
    return _node.free_list(l)

def is_list_empty(arg1):
    r"""is_list_empty(node arg1) -> int"""
    return _node.is_list_empty(arg1)

def in_list(arg1, arg2):
    r"""in_list(node arg1, node arg2) -> int"""
    return _node.in_list(arg1, arg2)

def llength(arg1):
    r"""llength(node arg1) -> int"""
    return _node.llength(arg1)

def append(arg1, arg2):
    r"""append(node arg1, node arg2) -> node"""
    return _node.append(arg1, arg2)

def append_ns(arg1, arg2):
    r"""append_ns(node arg1, node arg2) -> node"""
    return _node.append_ns(arg1, arg2)

def reverse(arg1):
    r"""reverse(node arg1) -> node"""
    return _node.reverse(arg1)

def reverse_ns(arg1):
    r"""reverse_ns(node arg1) -> node"""
    return _node.reverse_ns(arg1)

def last(arg1):
    r"""last(node arg1) -> node"""
    return _node.last(arg1)

def map(fun, arg2):
    r"""map(NPFN fun, node arg2) -> node"""
    return _node.map(fun, arg2)

def map2(fun, arg2, arg3):
    r"""map2(NPFNN fun, node arg2, node arg3) -> node"""
    return _node.map2(fun, arg2, arg3)

def even_elements(arg1):
    r"""even_elements(node arg1) -> node"""
    return _node.even_elements(arg1)

def odd_elements(arg1):
    r"""odd_elements(node arg1) -> node"""
    return _node.odd_elements(arg1)

def node_subtract(arg1, arg2):
    r"""node_subtract(node arg1, node arg2) -> node"""
    return _node.node_subtract(arg1, arg2)

def find_node(arg1, arg2, arg3):
    r"""find_node(int arg1, node arg2, node arg3) -> node"""
    return _node.find_node(arg1, arg2, arg3)

def find_atom(arg1):
    r"""find_atom(node arg1) -> node"""
    return _node.find_atom(arg1)

def print_sexp(arg1, arg2):
    r"""print_sexp(FILE * arg1, node arg2) -> int"""
    return _node.print_sexp(arg1, arg2)

def print_array_type(output_stream, body):
    r"""print_array_type(FILE * output_stream, node body)"""
    return _node.print_array_type(output_stream, body)

def print_node(arg1, arg2):
    r"""print_node(FILE * arg1, node arg2) -> int"""
    return _node.print_node(arg1, arg2)

def sprint_node(arg1):
    r"""sprint_node(node arg1) -> char *"""
    return _node.sprint_node(arg1)

def print_node_indent_at(stream, n, ofs):
    r"""print_node_indent_at(FILE * stream, node n, int ofs) -> int"""
    return _node.print_node_indent_at(stream, n, ofs)

def sprint_node_indent_at(n, ofs):
    r"""sprint_node_indent_at(node n, int ofs) -> char *"""
    return _node.sprint_node_indent_at(n, ofs)

def print_node_indent(stream, n):
    r"""print_node_indent(FILE * stream, node n) -> int"""
    return _node.print_node_indent(stream, n)

def sprint_node_indent(n):
    r"""sprint_node_indent(node n) -> char *"""
    return _node.sprint_node_indent(n)

def setcar(arg1, arg2):
    r"""setcar(node arg1, node arg2)"""
    return _node.setcar(arg1, arg2)

def setcdr(arg1, arg2):
    r"""setcdr(node arg1, node arg2)"""
    return _node.setcdr(arg1, arg2)

def node_set_type(arg1, arg2):
    r"""node_set_type(node arg1, int arg2)"""
    return _node.node_set_type(arg1, arg2)

def node_normalize(arg1):
    r"""node_normalize(node arg1) -> node"""
    return _node.node_normalize(arg1)

def node_normalize_list(sexp):
    r"""node_normalize_list(node sexp) -> node"""
    return _node.node_normalize_list(sexp)

def node_pkg_get_global_master_normalizer():
    r"""node_pkg_get_global_master_normalizer() -> struct MasterNormalizer_TAG *"""
    return _node.node_pkg_get_global_master_normalizer()

def node_pkg_get_global_master_wff_printer():
    r"""node_pkg_get_global_master_wff_printer() -> struct MasterPrinter_TAG *"""
    return _node.node_pkg_get_global_master_wff_printer()

def node_pkg_get_global_master_sexp_printer():
    r"""node_pkg_get_global_master_sexp_printer() -> struct MasterPrinter_TAG *"""
    return _node.node_pkg_get_global_master_sexp_printer()

def node_pkg_get_indenting_master_wff_printer():
    r"""node_pkg_get_indenting_master_wff_printer() -> struct MasterPrinter_TAG *"""
    return _node.node_pkg_get_indenting_master_wff_printer()

def NodeWalker_destroy(_self):
    r"""NodeWalker_destroy(NodeWalker_ptr _self)"""
    return _node.NodeWalker_destroy(_self)

def NodeWalker_can_handle(_self, n):
    r"""NodeWalker_can_handle(NodeWalker_ptr const _self, node n) -> boolean"""
    return _node.NodeWalker_can_handle(_self, n)

def NodeWalker_get_name(_self):
    r"""NodeWalker_get_name(NodeWalker_ptr const _self) -> char const *"""
    return _node.NodeWalker_get_name(_self)

def NodeWalker_collides(_self, other):
    r"""NodeWalker_collides(NodeWalker_ptr const _self, NodeWalker_ptr const other) -> boolean"""
    return _node.NodeWalker_collides(_self, other)

