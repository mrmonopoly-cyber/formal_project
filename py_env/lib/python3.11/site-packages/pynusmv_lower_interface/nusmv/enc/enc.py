# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _enc
else:
    import _enc

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


PRIuPTR = _enc.PRIuPTR

PRIdPTR = _enc.PRIdPTR

LLU = _enc.LLU

LLO = _enc.LLO

LLX = _enc.LLX

false = _enc.false

true = _enc.true

OUTCOME_GENERIC_ERROR = _enc.OUTCOME_GENERIC_ERROR

OUTCOME_PARSER_ERROR = _enc.OUTCOME_PARSER_ERROR

OUTCOME_SYNTAX_ERROR = _enc.OUTCOME_SYNTAX_ERROR

OUTCOME_FILE_ERROR = _enc.OUTCOME_FILE_ERROR

OUTCOME_SUCCESS_REQUIRED_HELP = _enc.OUTCOME_SUCCESS_REQUIRED_HELP

OUTCOME_SUCCESS = _enc.OUTCOME_SUCCESS

VARS_ORD_INPUTS_BEFORE = _enc.VARS_ORD_INPUTS_BEFORE

VARS_ORD_INPUTS_AFTER = _enc.VARS_ORD_INPUTS_AFTER

VARS_ORD_TOPOLOGICAL = _enc.VARS_ORD_TOPOLOGICAL

VARS_ORD_INPUTS_BEFORE_BI = _enc.VARS_ORD_INPUTS_BEFORE_BI

VARS_ORD_INPUTS_AFTER_BI = _enc.VARS_ORD_INPUTS_AFTER_BI

VARS_ORD_TOPOLOGICAL_BI = _enc.VARS_ORD_TOPOLOGICAL_BI

VARS_ORD_UNKNOWN = _enc.VARS_ORD_UNKNOWN

BDD_STATIC_ORDER_HEURISTICS_NONE = _enc.BDD_STATIC_ORDER_HEURISTICS_NONE

BDD_STATIC_ORDER_HEURISTICS_BASIC = _enc.BDD_STATIC_ORDER_HEURISTICS_BASIC

BDD_STATIC_ORDER_HEURISTICS_ERROR = _enc.BDD_STATIC_ORDER_HEURISTICS_ERROR


def Enc_init_encodings():
    r"""Enc_init_encodings()"""
    return _enc.Enc_init_encodings()

def Enc_init_bool_encoding():
    r"""Enc_init_bool_encoding()"""
    return _enc.Enc_init_bool_encoding()

def Enc_init_bdd_encoding():
    r"""Enc_init_bdd_encoding()"""
    return _enc.Enc_init_bdd_encoding()

def Enc_init_be_encoding():
    r"""Enc_init_be_encoding()"""
    return _enc.Enc_init_be_encoding()

def Enc_quit_encodings():
    r"""Enc_quit_encodings()"""
    return _enc.Enc_quit_encodings()

def Enc_add_commands():
    r"""Enc_add_commands()"""
    return _enc.Enc_add_commands()

def Enc_get_bool_encoding():
    r"""Enc_get_bool_encoding() -> BoolEnc_ptr"""
    return _enc.Enc_get_bool_encoding()

def Enc_get_bdd_encoding():
    r"""Enc_get_bdd_encoding() -> BddEnc_ptr"""
    return _enc.Enc_get_bdd_encoding()

def Enc_get_be_encoding():
    r"""Enc_get_be_encoding() -> BeEnc_ptr"""
    return _enc.Enc_get_be_encoding()

def Enc_set_bool_encoding(benc):
    r"""Enc_set_bool_encoding(BoolEnc_ptr benc)"""
    return _enc.Enc_set_bool_encoding(benc)

def Enc_set_bdd_encoding(enc):
    r"""Enc_set_bdd_encoding(BddEnc_ptr enc)"""
    return _enc.Enc_set_bdd_encoding(enc)

def Enc_set_be_encoding(enc):
    r"""Enc_set_be_encoding(BeEnc_ptr enc)"""
    return _enc.Enc_set_be_encoding(enc)

def Enc_vars_ord_to_string(arg1):
    r"""Enc_vars_ord_to_string(VarsOrdType arg1) -> char const *"""
    return _enc.Enc_vars_ord_to_string(arg1)

def Enc_string_to_vars_ord(arg1):
    r"""Enc_string_to_vars_ord(char const * arg1) -> VarsOrdType"""
    return _enc.Enc_string_to_vars_ord(arg1)

def Enc_get_valid_vars_ord_types():
    r"""Enc_get_valid_vars_ord_types() -> char const *"""
    return _enc.Enc_get_valid_vars_ord_types()

def Enc_bdd_static_order_heuristics_to_string(arg1):
    r"""Enc_bdd_static_order_heuristics_to_string(BddSohEnum arg1) -> char const *"""
    return _enc.Enc_bdd_static_order_heuristics_to_string(arg1)

def Enc_string_to_bdd_static_order_heuristics(arg1):
    r"""Enc_string_to_bdd_static_order_heuristics(char const * arg1) -> BddSohEnum"""
    return _enc.Enc_string_to_bdd_static_order_heuristics(arg1)

def Enc_get_valid_bdd_static_order_heuristics():
    r"""Enc_get_valid_bdd_static_order_heuristics() -> char const *"""
    return _enc.Enc_get_valid_bdd_static_order_heuristics()

def node_and(n1, n2):
    r"""node_and(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_and(n1, n2)

def node_or(n1, n2):
    r"""node_or(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_or(n1, n2)

def node_not(n, this_node_not_used):
    r"""node_not(node_ptr n, node_ptr this_node_not_used) -> node_ptr"""
    return _enc.node_not(n, this_node_not_used)

def node_iff(n1, n2):
    r"""node_iff(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_iff(n1, n2)

def node_xor(n1, n2):
    r"""node_xor(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_xor(n1, n2)

def node_implies(n1, n2):
    r"""node_implies(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_implies(n1, n2)

def node_equal(n1, n2):
    r"""node_equal(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_equal(n1, n2)

def node_not_equal(n1, n2):
    r"""node_not_equal(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_not_equal(n1, n2)

def node_lt(n1, n2):
    r"""node_lt(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_lt(n1, n2)

def node_gt(n1, n2):
    r"""node_gt(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_gt(n1, n2)

def node_le(n1, n2):
    r"""node_le(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_le(n1, n2)

def node_ge(n1, n2):
    r"""node_ge(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_ge(n1, n2)

def node_unary_minus(n1, n2):
    r"""node_unary_minus(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_unary_minus(n1, n2)

def node_plus(n1, n2):
    r"""node_plus(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_plus(n1, n2)

def node_minus(n1, n2):
    r"""node_minus(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_minus(n1, n2)

def node_times(n1, n2):
    r"""node_times(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_times(n1, n2)

def node_divide(n1, n2):
    r"""node_divide(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_divide(n1, n2)

def node_mod(n1, n2):
    r"""node_mod(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_mod(n1, n2)

def node_bit_range(n1, n2):
    r"""node_bit_range(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_bit_range(n1, n2)

def node_union(n1, n2):
    r"""node_union(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_union(n1, n2)

def node_setin(n1, n2):
    r"""node_setin(node_ptr n1, node_ptr n2) -> node_ptr"""
    return _enc.node_setin(n1, n2)

def node_word_get_width(w):
    r"""node_word_get_width(node_ptr w) -> size_t"""
    return _enc.node_word_get_width(w)

def node_word_create(bitval, w):
    r"""node_word_create(node_ptr bitval, size_t w) -> node_ptr"""
    return _enc.node_word_create(bitval, w)

def node_word_create_from_list(l, w):
    r"""node_word_create_from_list(node_ptr l, size_t w) -> node_ptr"""
    return _enc.node_word_create_from_list(l, w)

def node_word_create_from_wordnumber(wn):
    r"""node_word_create_from_wordnumber(WordNumber_ptr wn) -> node_ptr"""
    return _enc.node_word_create_from_wordnumber(wn)

def node_word_create_from_integer(value, width):
    r"""node_word_create_from_integer(unsigned long long value, size_t width) -> node_ptr"""
    return _enc.node_word_create_from_integer(value, width)

def node_word_create_from_array(arr):
    r"""node_word_create_from_array(array_t * arr) -> node_ptr"""
    return _enc.node_word_create_from_array(arr)

def node_word_to_array(w):
    r"""node_word_to_array(node_ptr w) -> array_t *"""
    return _enc.node_word_to_array(w)

def node_word_apply_unary(wenc, op):
    r"""node_word_apply_unary(node_ptr wenc, int op) -> node_ptr"""
    return _enc.node_word_apply_unary(wenc, op)

def node_word_apply_attime(wenc, time):
    r"""node_word_apply_attime(node_ptr wenc, int time) -> node_ptr"""
    return _enc.node_word_apply_attime(wenc, time)

def node_word_apply_binary(wenc1, wenc2, op):
    r"""node_word_apply_binary(node_ptr wenc1, node_ptr wenc2, int op) -> node_ptr"""
    return _enc.node_word_apply_binary(wenc1, wenc2, op)

def node_word_make_conjuction(w):
    r"""node_word_make_conjuction(node_ptr w) -> node_ptr"""
    return _enc.node_word_make_conjuction(w)

def node_word_make_disjunction(w):
    r"""node_word_make_disjunction(node_ptr w) -> node_ptr"""
    return _enc.node_word_make_disjunction(w)

def node_word_cast_bool(w):
    r"""node_word_cast_bool(node_ptr w) -> node_ptr"""
    return _enc.node_word_cast_bool(w)

def node_word_not(w):
    r"""node_word_not(node_ptr w) -> node_ptr"""
    return _enc.node_word_not(w)

def node_word_and(a, b):
    r"""node_word_and(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_and(a, b)

def node_word_or(a, b):
    r"""node_word_or(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_or(a, b)

def node_word_xor(a, b):
    r"""node_word_xor(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_xor(a, b)

def node_word_xnor(a, b):
    r"""node_word_xnor(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_xnor(a, b)

def node_word_implies(a, b):
    r"""node_word_implies(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_implies(a, b)

def node_word_iff(a, b):
    r"""node_word_iff(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_iff(a, b)

def node_word_equal(a, b):
    r"""node_word_equal(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_equal(a, b)

def node_word_notequal(a, b):
    r"""node_word_notequal(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_notequal(a, b)

def node_word_concat(a, b):
    r"""node_word_concat(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_concat(a, b)

def node_word_selection(word, range):
    r"""node_word_selection(node_ptr word, node_ptr range) -> node_ptr"""
    return _enc.node_word_selection(word, range)

def node_word_extend(a, b, isSigned):
    r"""node_word_extend(node_ptr a, node_ptr b, boolean isSigned) -> node_ptr"""
    return _enc.node_word_extend(a, b, isSigned)

def node_word_adder(a, b, carry_in, carry_out):
    r"""node_word_adder(node_ptr a, node_ptr b, node_ptr carry_in, node_ptr * carry_out) -> node_ptr"""
    return _enc.node_word_adder(a, b, carry_in, carry_out)

def node_word_plus(a, b):
    r"""node_word_plus(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_plus(a, b)

def node_word_minus(a, b):
    r"""node_word_minus(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_minus(a, b)

def node_word_uminus(a):
    r"""node_word_uminus(node_ptr a) -> node_ptr"""
    return _enc.node_word_uminus(a)

def node_word_times(a, b):
    r"""node_word_times(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_times(a, b)

def node_word_unsigned_divide(a, b):
    r"""node_word_unsigned_divide(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_unsigned_divide(a, b)

def node_word_unsigned_mod(a, b):
    r"""node_word_unsigned_mod(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_unsigned_mod(a, b)

def node_word_signed_divide(a, b):
    r"""node_word_signed_divide(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_signed_divide(a, b)

def node_word_signed_mod(a, b):
    r"""node_word_signed_mod(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_signed_mod(a, b)

def node_word_unsigned_less(a, b):
    r"""node_word_unsigned_less(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_unsigned_less(a, b)

def node_word_unsigned_less_equal(a, b):
    r"""node_word_unsigned_less_equal(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_unsigned_less_equal(a, b)

def node_word_unsigned_greater(a, b):
    r"""node_word_unsigned_greater(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_unsigned_greater(a, b)

def node_word_unsigned_greater_equal(a, b):
    r"""node_word_unsigned_greater_equal(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_unsigned_greater_equal(a, b)

def node_word_signed_less(a, b):
    r"""node_word_signed_less(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_signed_less(a, b)

def node_word_signed_less_equal(a, b):
    r"""node_word_signed_less_equal(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_signed_less_equal(a, b)

def node_word_signed_greater(a, b):
    r"""node_word_signed_greater(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_signed_greater(a, b)

def node_word_signed_greater_equal(a, b):
    r"""node_word_signed_greater_equal(node_ptr a, node_ptr b) -> node_ptr"""
    return _enc.node_word_signed_greater_equal(a, b)

cvar = _enc.cvar

